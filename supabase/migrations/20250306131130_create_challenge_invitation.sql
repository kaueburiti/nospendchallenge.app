-- Create challenge invitations table
CREATE TABLE public.challenge_invitations (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    challenge_id bigint REFERENCES public.challenges(id) ON DELETE CASCADE NOT NULL,
    inviter_id uuid REFERENCES auth.users NOT NULL,
    invitee_email text NOT NULL,
    status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined')),
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL
);

-- Add unique constraint to prevent duplicate invitations
ALTER TABLE public.challenge_invitations 
ADD CONSTRAINT unique_challenge_invitation 
UNIQUE (challenge_id, invitee_email);

-- Enable Row Level Security
ALTER TABLE public.challenge_invitations ENABLE ROW LEVEL SECURITY;

-- Create policies
-- Allow authenticated users to read their own invitations (as inviter or by email)
CREATE POLICY "Users can read their own invitations"
    ON public.challenge_invitations
    FOR SELECT
    TO authenticated
    USING (
        inviter_id = auth.uid() OR 
        invitee_email = (SELECT email FROM auth.users WHERE id = auth.uid())
    );

-- Allow authenticated users to insert invitations for challenges they own
CREATE POLICY "Users can invite to their own challenges"
    ON public.challenge_invitations
    FOR INSERT
    TO authenticated
    WITH CHECK (
        inviter_id = auth.uid() AND
        EXISTS (
            SELECT 1 FROM public.challenges 
            WHERE id = challenge_id AND owner_id = auth.uid()
        )
    );

-- Allow users to update invitations they received
CREATE POLICY "Users can update invitations they received"
    ON public.challenge_invitations
    FOR UPDATE
    TO authenticated
    USING (
        invitee_email = (SELECT email FROM auth.users WHERE id = auth.uid())
    )
    WITH CHECK (
        invitee_email = (SELECT email FROM auth.users WHERE id = auth.uid()) AND
        (status = 'accepted' OR status = 'declined')
    );

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to update updated_at timestamp
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON public.challenge_invitations
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- Create challenge participants table to track who joined challenges
CREATE TABLE public.challenge_participants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    challenge_id bigint REFERENCES public.challenges(id) ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES auth.users NOT NULL,
    joined_at timestamptz DEFAULT now() NOT NULL,
    UNIQUE(challenge_id, user_id)
);

-- Enable Row Level Security
ALTER TABLE public.challenge_participants ENABLE ROW LEVEL SECURITY;

-- Create policies
-- Allow authenticated users to read all participants
CREATE POLICY "Authenticated users can read all participants"
    ON public.challenge_participants
    FOR SELECT
    TO authenticated
    USING (true);

-- Allow authenticated users to join challenges they're invited to
CREATE POLICY "Users can join challenges they're invited to"
    ON public.challenge_participants
    FOR INSERT
    TO authenticated
    WITH CHECK (
        user_id = auth.uid() AND
        (
            -- User is the owner of the challenge
            EXISTS (
                SELECT 1 FROM public.challenges 
                WHERE id = challenge_id AND owner_id = auth.uid()
            ) OR
            -- User has an accepted invitation
            EXISTS (
                SELECT 1 FROM public.challenge_invitations 
                WHERE challenge_id = challenge_participants.challenge_id 
                AND invitee_email = (SELECT email FROM auth.users WHERE id = auth.uid())
                AND status = 'accepted'
            )
        )
    );

-- Allow authenticated users to leave challenges they joined
CREATE POLICY "Users can leave challenges they joined"
    ON public.challenge_participants
    FOR DELETE
    TO authenticated
    USING (user_id = auth.uid());